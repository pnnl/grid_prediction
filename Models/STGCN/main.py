'''
Date created: Feb 18, 2020
Date updated: Mar 25, 2021
Author: Sheng Guan, working with PNNL on PowerDrone project
'''
import helper_fcns
import configparser
from time import process_time
from training_preparation import *
from get_adjacency_matrix import *
from data_gen_powerGrid import *
import re
from memory_profiler import profile


import os

os.environ["CUDA_VISIBLE_DEVICES"] = "0"
from os.path import join as pjoin

import tensorflow as tf

config = tf.ConfigProto()
config.gpu_options.allow_growth = True
tf.Session(config=config)

from utils.math_graph import *
from data_loader.data_utils import *
from models.trainer import transient_model_train
from models.tester import model_test_withGroundTruth, transient_model_test

import argparse


parser = argparse.ArgumentParser()
#Define the training scenarios, validation scenarios and test scenarios from the configuration file
parser.add_argument("--config", default='configurations/pnnl_stgcn.conf', type=str,
                    help="configuration file path")
#Define the number of nodes in your network e.g. # of PMUs in power network
parser.add_argument('--n_route', type=int, default=68)
#The observation window length you defined, notice that your observation length should be smaller than the inference starting point (p_start_t defined in the below argument)
parser.add_argument('--n_his', type=int, default=199)
#To incorporate with varied test_pred_length, this version of code fixes the n_pred as constant value 1
parser.add_argument('--n_pred', type=int, default=1)
#The val_pred_length is defined to be larger than n_his based on application needs
#Specifically, in the power network, the n_his as 200 time steps correspond to 4s physical scenario. 
#Usually, the power-network application needs to predict for the future 10s, equals to length as 500
parser.add_argument('--val_pred_length', type=int, default=500)
parser.add_argument('--batch_size', type=int, default=10)
parser.add_argument('--epoch', type=int, default=2)
parser.add_argument('--save', type=int, default=1)
parser.add_argument('--ks', type=int, default=1)
parser.add_argument('--kt', type=int, default=1)
parser.add_argument('--lr', type=float, default=1e-3)
parser.add_argument('--opt', type=str, default='RMSProp')
parser.add_argument('--graph', type=str, default='default')
##inf_mode as sep, only can predict one particular time stamp in the future
##inf_mode as merge, can predict a segment of future time stamp, such as next 50 time steps
parser.add_argument('--inf_mode', type=str, default='merge')
#define for the test case, the starting prediction point
parser.add_argument('--p_start_t', type= int, default=200)
##feature selects from frequency, voltage, angle
parser.add_argument('--feature', type=str, default='frequency')
#The test_pred_length is defined to be larger than n_his based on application needs
#Specifically, in the power network, the n_his as 200 time steps correspond to 4s physical scenario. 
#Usually, the power-network application needs to predict for the future 10s, equals to length as 500
parser.add_argument('--test_pred_length', type=int, default=500)


args = parser.parse_args()
config = configparser.ConfigParser()
print('Read configuration file: %s' % (args.config))
config.read(args.config)
print(f'Training configs: {args}')

#get the number of buses, number of history window size, number of prediction size
n, n_his, n_pred = args.n_route, args.n_his, args.n_pred
#to incorporate with changing test_pred_prediciton length, the test_pred is fixed as 1.
#then, future predictions are generated by concatenation
test_pred = 1
Ks, Kt = args.ks, args.kt

# blocks: settings of channel size in st_conv_blocks / bottleneck design
blocks = [[1, 32, 64], [64, 32, 128]]
measure = args.feature
test_pred_length = args.test_pred_length
val_pred_length = args.val_pred_length


tic = process_time()
print('[INFO]: Loading all the datasets for training, validation and testing. ')
#sys_data = helper_fcns.SystemData('/Results/IEEE68busSystem/')
scenario_dir = 'Results/IEEE68busSystem/Training'

#load the configuration file to read train/valid/test scenarios
dir_list = config['data']['dir_list'].strip('][').split(' ')



# Indicate the scenario range
Dataset = dict()
print('[INFO]: Loading data for %d scenarios ...' % len(dir_list))

scenario_data = []
count = 0
for s_dir in dir_list:
    if s_dir.find('scenario') == -1:
        continue
    dataset = helper_fcns.TransientDataset('/%s/%s/' % (scenario_dir, s_dir))
    #### F means for frequency
    #### Vm means for voltage
    #### Va means for angle
    if measure =='angle':
        scenario_data.append(dataset.Va)
    elif measure =='frequency':
        scenario_data.append(dataset.F)
    elif measure =='voltage':
        scenario_data.append(dataset.Vm)
    count += 1
    if count % 10 == 0:
        print('[INFO]: Loaded %d/%d scenarios ...' % (count, len(dir_list)))

print('[INFO]: Done ...')
valid_data = scenario_data[-2]
test_data = scenario_data[-1]

save_path = './output/models/'


feature_matrix, x_flag = training_preparation(scenario_data,save_path,measure)

#calculate the adjacency matrix
adj = get_adjacency_matrix(pjoin('./dataset/PowerGrid', f'powerGrid_distance.csv'),n)


# Calculate graph kernel
L = scaled_laplacian(adj)
# Alternative approximation method: 1st approx - first_approx(W, n).
Lk = cheb_poly_approx(L, Ks, n)
tf.add_to_collection(name='graph_kernel', value=tf.cast(tf.constant(Lk), tf.float32))

# Data Preprocessing
n_train,n_val,n_test = int(config['partition']['n_train']), int(config['partition']['n_val']),  int(config['partition']['n_test'])

feats = second_data_gen_powerGrid(feature_matrix, (n_train, n_val, n_test), n, n_his+1, args.p_start_t, n_his,val_pred_length,test_pred_length)


#Note even for the same saved model, the training/validation/test partition will affect the RMSE and MAE score!!!
#The prediction result will change since the mean of the input matrix will change
test_scenario = s_dir


if __name__ == '__main__':

    print("Start model training process ...")
    #for the inference only, just comment the below line!!!
    transient_model_train(feats, blocks, args,x_flag,valid_data,test_data)
    
    ##An alternative method that feeds the future ground truth into the model
    '''
    model_test_withGroundTruth(feats, args, blocks, feats.get_len('test'), n_his, test_pred, args.inf_mode, args.p_start_t, n_pred,\
    scenario_data,test_pred_length)
    '''

    #For the test scenario, infer starting from p_start_t, the prediction length is test_pred_length
    '''
    transient_model_test(feats, args, blocks, feats.get_len('test'), n_his, test_pred, args.inf_mode,
                               args.p_start_t, n_pred, \
                               scenario_data, test_pred_length, test_scenario, test_data)
    '''